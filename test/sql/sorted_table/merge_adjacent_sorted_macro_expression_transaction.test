# name: test/sql/sorted_table/merge_adjacent_sorted_macro_expression_transaction.test
# description: Sort by a DuckLake macro to approximate space filling curve sorting within a transaction
# group: [sorted_table]

require ducklake

require parquet


test-env DUCKLAKE_CONNECTION __TEST_DIR__/{UUID}.db


statement ok
ATTACH 'ducklake:${DUCKLAKE_CONNECTION}' AS ducklake (DATA_PATH '__TEST_DIR__/merge_adjacent_sorted_macro_expression_transaction/')

statement ok
USE ducklake;

# Create a table with a unique_id column for nested expression sorting
statement ok
CREATE TABLE macro_sort_test (i VARCHAR, j VARCHAR);

statement ok
INSERT INTO macro_sort_test 
SELECT 'ZYX' AS i, 'CBA' AS j 
UNION ALL 
SELECT 'ABC' AS i, 'XYZ' AS j 


statement ok
INSERT INTO macro_sort_test 
SELECT '321' AS i, '000' AS j 
UNION ALL 
SELECT '123' AS i, '000' AS j 

# Verify we have 2 data files before compaction
query II
SELECT df.data_file_id, df.table_id
FROM __ducklake_metadata_ducklake.ducklake_data_file df
JOIN __ducklake_metadata_ducklake.ducklake_table t
ON df.table_id = t.table_id
WHERE
t.table_name = 'macro_sort_test'
----
0	1
1	1

statement ok
BEGIN

statement ok
CREATE MACRO zip_varchar(i, j, num_chars := 6) AS (
    -- By default using 6 characters from each string so that
    -- if data is ASCII, we can fit it all in 12 bytes so that it is stored inline
    -- rather than requiring a pointer
    [
	   list_value(z[1], z[2])
	   FOR z
	   IN list_zip(
		  substr(i, 1, num_chars).rpad(num_chars, ' ').string_split(''),
		  substr(j, 1, num_chars).rpad(num_chars, ' ').string_split('')
	   )
    ].flatten().array_to_string('')
);

# Test that the macro is working as intended independently of sorting
query III
SELECT
    'ABC' AS i,
    'XYZ' AS j,
    zip_varchar(i, j, num_chars := 3) AS zipped_varchar;
----
ABC	XYZ	AXBYCZ

# Set sorted 
statement ok
ALTER TABLE ducklake.macro_sort_test SET SORTED BY (zip_varchar(i, j, num_chars := 3) ASC NULLS LAST);

statement ok
COMMIT

# Verify data before compaction (should be in insertion order)
query III
SELECT i, j, zip_varchar(i, j, num_chars := 3)
FROM macro_sort_test
----
ZYX	CBA	ZCYBXA
ABC	XYZ	AXBYCZ
321	000	302010
123	000	102030

# Compact the files
statement ok
CALL ducklake_merge_adjacent_files('ducklake', 'macro_sort_test');

# Verify we have 1 data file after compaction
query II
SELECT df.data_file_id, df.table_id
FROM __ducklake_metadata_ducklake.ducklake_data_file df
JOIN __ducklake_metadata_ducklake.ducklake_table t
ON df.table_id = t.table_id
WHERE
t.table_name = 'macro_sort_test'
----
2	1

# Verify data is now sorted by the macro
query III
SELECT i, j, zip_varchar(i, j, num_chars := 3)
FROM macro_sort_test
----
123	000	102030
321	000	302010
ABC	XYZ	AXBYCZ
ZYX	CBA	ZCYBXA
