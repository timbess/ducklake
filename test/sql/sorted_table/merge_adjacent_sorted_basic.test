# name: test/sql/sorted_table/merge_adjacent_sorted_basic.test
# description: test ducklake merge adjacent files with SET SORTED BY metadata
# group: [sorted_table]

require ducklake

require parquet

test-env DUCKLAKE_CONNECTION __TEST_DIR__/{UUID}.db



statement ok
ATTACH 'ducklake:${DUCKLAKE_CONNECTION}' AS ducklake (DATA_PATH '__TEST_DIR__/merge_adjacent_options_sorted/')

statement ok
USE ducklake;

# Create one Table with two files
statement ok
CREATE TABLE sort_on_compaction (unique_id BIGINT, sort_key_1 BIGINT, sort_key_2 VARCHAR);

statement ok
INSERT INTO sort_on_compaction (unique_id, sort_key_1, sort_key_2)
FROM range(4) t(i)
SELECT 
    i AS unique_id,
    i % 2 AS sort_key_1,
    'woot' || i AS sort_key_2
ORDER BY 
    i DESC
;

statement ok
INSERT INTO sort_on_compaction (unique_id, sort_key_1, sort_key_2)
FROM range(4) t(i)
SELECT 
    i + 4 AS unique_id,
    (i + 4) % 2 AS sort_key_1,
    'woot' || (i + 4) AS sort_key_2
ORDER BY 
    i DESC
;

query III
FROM sort_on_compaction
----
3	1	woot3
2	0	woot2
1	1	woot1
0	0	woot0
7	1	woot7
6	0	woot6
5	1	woot5
4	0	woot4

query II
SELECT df.data_file_id, df.table_id 
FROM __ducklake_metadata_ducklake.ducklake_data_file df 
JOIN __ducklake_metadata_ducklake.ducklake_table t 
ON df.table_id = t.table_id 
WHERE 
t.table_name = 'sort_on_compaction'
ORDER BY ALL
----
0	1
1	1

statement ok
ALTER TABLE ducklake.sort_on_compaction SET SORTED BY (sort_key_1 ASC NULLS LAST, sort_key_2 ASC NULLS LAST);

# Validate snapshot changes - SET SORTED BY should NOT increment schema_version
query I
SELECT max(schema_version) FROM __ducklake_metadata_ducklake.ducklake_schema_versions where table_id = 1
----
1

# Ensure that the snapshot changes match expectations
query III
SELECT snapshot_id, schema_version, changes FROM ducklake_snapshots('ducklake')
----
0	0	{schemas_created=[main]}
1	1	{tables_created=[main.sort_on_compaction]}
2	1	{tables_inserted_into=[1]}
3	1	{tables_inserted_into=[1]}
4	2	{tables_altered=[1]}

# Even multiple changes back to back should not change the schema_version
statement ok
ALTER TABLE ducklake.sort_on_compaction SET SORTED BY (sort_key_1 DESC, sort_key_2 DESC);

statement ok
ALTER TABLE ducklake.sort_on_compaction SET SORTED BY (sort_key_1 ASC NULLS LAST, sort_key_2 ASC NULLS LAST);

# Validate snapshot changes - SET SORTED BY should NOT increment schema_version
query I
SELECT max(schema_version) FROM __ducklake_metadata_ducklake.ducklake_schema_versions where table_id = 1
----
1

# Ensure that the snapshot changes match expectations
query III
SELECT snapshot_id, schema_version, changes FROM ducklake_snapshots('ducklake')
----
0	0	{schemas_created=[main]}
1	1	{tables_created=[main.sort_on_compaction]}
2	1	{tables_inserted_into=[1]}
3	1	{tables_inserted_into=[1]}
4	2	{tables_altered=[1]}
5	3	{tables_altered=[1]}
6	4	{tables_altered=[1]}

# Do some other kind of alter table on that table to make sure that it does not interfere
statement ok
ALTER TABLE sort_on_compaction ADD COLUMN new_column INTEGER;

query III
SELECT table_name, files_processed, files_created FROM ducklake_merge_adjacent_files('ducklake', 'sort_on_compaction')
----
sort_on_compaction	2	1

query IIII
FROM sort_on_compaction
----
0	0	woot0	NULL
2	0	woot2	NULL
4	0	woot4	NULL
6	0	woot6	NULL
1	1	woot1	NULL
3	1	woot3	NULL
5	1	woot5	NULL
7	1	woot7	NULL

# We write a new file for the table
query II
SELECT df.data_file_id, df.table_id 
FROM __ducklake_metadata_ducklake.ducklake_data_file df 
JOIN __ducklake_metadata_ducklake.ducklake_table t 
ON df.table_id = t.table_id 
WHERE 
t.table_name = 'sort_on_compaction'
----
2	1


# Column does not exist in the table
statement error
ALTER TABLE sort_on_compaction SET SORTED BY (WOOOOT ASC ,   BLAH ASC);
----
Columns in the SET SORTED BY statement were not found in the DuckLake table. Unmatched columns were: WOOOOT, BLAH

# Expressions are now supported in SET SORTED BY
statement ok
ALTER TABLE sort_on_compaction SET SORTED BY (concat(sort_key_1, '_', sort_key_2) ASC);

# Reset back to simple column sort for the rest of the test
statement ok
ALTER TABLE sort_on_compaction SET SORTED BY (sort_key_1 ASC NULLS LAST, sort_key_2 ASC NULLS LAST);

# Drop the table, then expire the snapshots, then validate that the catalog data has been removed

# Pre-expiration catalog status:
query IIIIIII
SELECT
si.table_id, si.begin_snapshot, si.end_snapshot, se.sort_key_index, se.expression, se.sort_direction, se.null_order
FROM __ducklake_metadata_ducklake.ducklake_sort_info si
JOIN __ducklake_metadata_ducklake.ducklake_sort_expression se USING (sort_id)
JOIN __ducklake_metadata_ducklake.ducklake_table t
ON si.table_id = t.table_id
WHERE
t.table_name = 'sort_on_compaction'
ORDER BY ALL
----
1	4	5	0	sort_key_1	ASC	NULLS_LAST
1	4	5	1	sort_key_2	ASC	NULLS_LAST
1	5	6	0	sort_key_1	DESC	NULLS_LAST
1	5	6	1	sort_key_2	DESC	NULLS_LAST
1	6	9	0	sort_key_1	ASC	NULLS_LAST
1	6	9	1	sort_key_2	ASC	NULLS_LAST
1	9	10	0	concat(sort_key_1, '_', sort_key_2)	ASC	NULLS_LAST
1	10	NULL	0	sort_key_1	ASC	NULLS_LAST
1	10	NULL	1	sort_key_2	ASC	NULLS_LAST


statement ok
drop table sort_on_compaction;

# History should be present as long as the snapshots are not yet expired
query IIIIIII
SELECT
si.table_id, si.begin_snapshot, si.end_snapshot, se.sort_key_index, se.expression, se.sort_direction, se.null_order
FROM __ducklake_metadata_ducklake.ducklake_sort_info si
JOIN __ducklake_metadata_ducklake.ducklake_sort_expression se USING (sort_id)
JOIN __ducklake_metadata_ducklake.ducklake_table t
ON si.table_id = t.table_id
WHERE
t.table_name = 'sort_on_compaction'
ORDER BY ALL
----
1	4	5	0	sort_key_1	ASC	NULLS_LAST
1	4	5	1	sort_key_2	ASC	NULLS_LAST
1	5	6	0	sort_key_1	DESC	NULLS_LAST
1	5	6	1	sort_key_2	DESC	NULLS_LAST
1	6	9	0	sort_key_1	ASC	NULLS_LAST
1	6	9	1	sort_key_2	ASC	NULLS_LAST
1	9	10	0	concat(sort_key_1, '_', sort_key_2)	ASC	NULLS_LAST
1	10	11	0	sort_key_1	ASC	NULLS_LAST
1	10	11	1	sort_key_2	ASC	NULLS_LAST

statement ok
CALL ducklake_expire_snapshots('ducklake', older_than => now());

# This should be empty now that there are no snapshots remaining that rely on this table
query IIII
SELECT
si.sort_id, si.table_id, si.begin_snapshot, si.end_snapshot 
FROM __ducklake_metadata_ducklake.ducklake_sort_info si
WHERE 
si.table_id = 1
----

# This should be empty now that there are no snapshots remaining that rely on this table
query IIIIIII
SELECT
se.sort_id, se.table_id, se.sort_key_index, se.expression, se.dialect, se.sort_direction, se.null_order
FROM __ducklake_metadata_ducklake.ducklake_sort_expression se
WHERE 
se.table_id = 1
----

